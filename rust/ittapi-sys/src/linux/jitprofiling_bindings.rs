/* automatically generated by rust-bindgen 0.69.5 */

#[doc = "<\\brief Send this to shutdown the agent.\n Use NULL for event data."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_SHUTDOWN: iJIT_jvm_event = 2;
#[doc = "<\\brief Send when dynamic code is\n JIT compiled and loaded into\n memory by the JIT engine, but\n before the code is executed.\n Use iJIT_Method_Load as event\n data."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED: iJIT_jvm_event = 13;
#[doc = "<\\brief Send when compiled dynamic\n code is being unloaded from memory.\n Use iJIT_Method_Load as event data."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_UNLOAD_START: iJIT_jvm_event = 14;
#[doc = "<\\brief Send to provide new content for\n a previously reported dynamic code.\n The previous content will be invalidated\n starting from the time of the notification.\n Use iJIT_Method_Load as event data but\n required fields are following:\n - method_id    identify the code to update.\n - method_load_address    specify start address\n                          within identified code range\n                          where update should be started.\n - method_size            specify length of updated code\n                          range."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_UPDATE: iJIT_jvm_event = 15;
#[doc = "<\\brief Send when an inline dynamic\n code is JIT compiled and loaded\n into memory by the JIT engine,\n but before the parent code region\n starts executing.\n Use iJIT_Method_Inline_Load as event data."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED: iJIT_jvm_event = 16;
#[doc = " @cond exclude_from_documentation"]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_UPDATE_V2: iJIT_jvm_event = 17;
#[doc = "<\\brief Send when a dynamic code is\n JIT compiled and loaded into\n memory by the JIT engine, but\n before the code is executed.\n Use iJIT_Method_Load_V2 as event data."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2: iJIT_jvm_event = 21;
#[doc = "<\\brief Send when a dynamic code is\n JIT compiled and loaded into\n memory by the JIT engine, but\n before the code is executed.\n Use iJIT_Method_Load_V3 as event data."]
pub const iJIT_jvm_event_iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V3: iJIT_jvm_event = 22;
#[doc = " @brief Enumerator for the types of notifications"]
pub type iJIT_jvm_event = ::std::os::raw::c_uint;
#[doc = " @brief Enumerator for the types of notifications"]
pub use self::iJIT_jvm_event as iJIT_JVM_EVENT;
#[doc = "<\\brief The agent is not running;\n iJIT_NotifyEvent calls will\n not be processed."]
pub const _iJIT_IsProfilingActiveFlags_iJIT_NOTHING_RUNNING: _iJIT_IsProfilingActiveFlags = 0;
#[doc = "<\\brief The agent is running and\n ready to process notifications."]
pub const _iJIT_IsProfilingActiveFlags_iJIT_SAMPLING_ON: _iJIT_IsProfilingActiveFlags = 1;
#[doc = " @brief Enumerator for the agent's mode"]
pub type _iJIT_IsProfilingActiveFlags = ::std::os::raw::c_uint;
#[doc = " @brief Enumerator for the agent's mode"]
pub use self::_iJIT_IsProfilingActiveFlags as iJIT_IsProfilingActiveFlags;
#[doc = " @brief Description of a single entry in the line number information of a code region.\n @details A table of line number entries gives information about how the reported code region\n is mapped to source file.\n Intel(R) VTune(TM) Profiler uses line number information to attribute\n the samples (virtual address) to a line number. \\n\n It is acceptable to report different code addresses for the same source line:\n @code\n   Offset LineNumber\n      1       2\n      12      4\n      15      2\n      18      1\n      21      30\n\n  VTune Profiler constructs the following table using the client data\n\n   Code subrange  Line number\n      0-1             2\n      1-12            4\n      12-15           2\n      15-18           1\n      18-21           30\n @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LineNumberInfo {
    #[doc = "<\\brief Offset from the begining of the code region."]
    pub Offset: ::std::os::raw::c_uint,
    #[doc = "<\\brief Matching source line number offset (from beginning of source file)."]
    pub LineNumber: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__LineNumberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_LineNumberInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LineNumberInfo>(),
        8usize,
        concat!("Size of: ", stringify!(_LineNumberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_LineNumberInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_LineNumberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LineNumberInfo),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LineNumber) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LineNumberInfo),
            "::",
            stringify!(LineNumber)
        )
    );
}
#[doc = " @brief Description of a single entry in the line number information of a code region.\n @details A table of line number entries gives information about how the reported code region\n is mapped to source file.\n Intel(R) VTune(TM) Profiler uses line number information to attribute\n the samples (virtual address) to a line number. \\n\n It is acceptable to report different code addresses for the same source line:\n @code\n   Offset LineNumber\n      1       2\n      12      4\n      15      2\n      18      1\n      21      30\n\n  VTune Profiler constructs the following table using the client data\n\n   Code subrange  Line number\n      0-1             2\n      1-12            4\n      12-15           2\n      15-18           1\n      18-21           30\n @endcode"]
pub type pLineNumberInfo = *mut _LineNumberInfo;
#[doc = " @brief Description of a single entry in the line number information of a code region.\n @details A table of line number entries gives information about how the reported code region\n is mapped to source file.\n Intel(R) VTune(TM) Profiler uses line number information to attribute\n the samples (virtual address) to a line number. \\n\n It is acceptable to report different code addresses for the same source line:\n @code\n   Offset LineNumber\n      1       2\n      12      4\n      15      2\n      18      1\n      21      30\n\n  VTune Profiler constructs the following table using the client data\n\n   Code subrange  Line number\n      0-1             2\n      1-12            4\n      12-15           2\n      15-18           1\n      18-21           30\n @endcode"]
pub type LineNumberInfo = _LineNumberInfo;
#[doc = "<\\brief Native to the process architecture that is calling it."]
pub const _iJIT_CodeArchitecture_iJIT_CA_NATIVE: _iJIT_CodeArchitecture = 0;
#[doc = "<\\brief 32-bit machine code."]
pub const _iJIT_CodeArchitecture_iJIT_CA_32: _iJIT_CodeArchitecture = 1;
#[doc = "<\\brief 64-bit machine code."]
pub const _iJIT_CodeArchitecture_iJIT_CA_64: _iJIT_CodeArchitecture = 2;
#[doc = " @brief Enumerator for the code architecture."]
pub type _iJIT_CodeArchitecture = ::std::os::raw::c_uint;
#[doc = " @brief Enumerator for the code architecture."]
pub use self::_iJIT_CodeArchitecture as iJIT_CodeArchitecture;
#[doc = " @brief Description of a JIT-compiled method\n @details When you use the iJIT_Method_Load structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED\n  as an event type to report it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iJIT_Method_Load {
    #[doc = "<\\brief Unique method ID. Cannot be 0.\n  You must either use the API function\n  iJIT_GetNewMethodID to get a valid and unique\n  method ID, or else manage ID uniqueness\n  and correct range by yourself.\\n\n  You must use the same method ID for all code\n  regions of the same method, otherwise different\n  method IDs specify different methods."]
    pub method_id: ::std::os::raw::c_uint,
    #[doc = "<\\brief The name of the method. It can be optionally\n  prefixed with its class name and appended with\n  its complete signature. Can't be NULL."]
    pub method_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief The start virtual address of the method code\n  region. If NULL, data provided with\n  event are not accepted."]
    pub method_load_address: *mut ::std::os::raw::c_void,
    #[doc = "<\\brief The code size of the method in memory.\n  If 0, then data provided with the event are not\n  accepted."]
    pub method_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief The number of entries in the line number\n  table.0 if none."]
    pub line_number_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief Pointer to the line numbers info\n  array. Can be NULL if\n  line_number_size is 0. See\n  LineNumberInfo Structure for a\n  description of a single entry in\n  the line number info array"]
    pub line_number_table: pLineNumberInfo,
    #[doc = "<\\brief This field is obsolete."]
    pub class_id: ::std::os::raw::c_uint,
    #[doc = "<\\brief Class name. Can be NULL."]
    pub class_file_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Source file name. Can be NULL."]
    pub source_file_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__iJIT_Method_Load() {
    const UNINIT: ::std::mem::MaybeUninit<_iJIT_Method_Load> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iJIT_Method_Load>(),
        64usize,
        concat!("Size of: ", stringify!(_iJIT_Method_Load))
    );
    assert_eq!(
        ::std::mem::align_of::<_iJIT_Method_Load>(),
        8usize,
        concat!("Alignment of ", stringify!(_iJIT_Method_Load))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(method_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(method_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_load_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(method_load_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(method_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(line_number_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_table) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(line_number_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_file_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(class_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_file_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load),
            "::",
            stringify!(source_file_name)
        )
    );
}
#[doc = " @brief Description of a JIT-compiled method\n @details When you use the iJIT_Method_Load structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED\n  as an event type to report it."]
pub type piJIT_Method_Load = *mut _iJIT_Method_Load;
#[doc = " @brief Description of a JIT-compiled method\n @details When you use the iJIT_Method_Load structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED\n  as an event type to report it."]
pub type iJIT_Method_Load = _iJIT_Method_Load;
#[doc = " @brief Description of a JIT-compiled method\n @details When you use the iJIT_Method_Load_V2 structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2\n  as an event type to report it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iJIT_Method_Load_V2 {
    #[doc = "<\\brief Unique method ID. Cannot be 0.\n  You must either use the API function\n  iJIT_GetNewMethodID to get a valid and unique\n  method ID, or else manage ID uniqueness\n  and correct range by yourself.\\n\n  You must use the same method ID for all code\n  regions of the same method, otherwise different\n  method IDs specify different methods."]
    pub method_id: ::std::os::raw::c_uint,
    #[doc = "<\\brief The name of the method. It can be optionally\n  prefixed with its class name and appended with\n  its complete signature. Can't be  NULL."]
    pub method_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief The start virtual address of the method code\n  region. If NULL, then data provided with the\n  event are not accepted."]
    pub method_load_address: *mut ::std::os::raw::c_void,
    #[doc = "<\\brief The code size of the method in memory.\n  If 0, then data provided with the event are not\n  accepted."]
    pub method_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief The number of entries in the line number\n  table. 0 if none."]
    pub line_number_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief Pointer to the line numbers info\n  array. Can be NULL if\n  line_number_size is 0. See\n  LineNumberInfo Structure for a\n  description of a single entry in\n  the line number info array."]
    pub line_number_table: pLineNumberInfo,
    #[doc = "<\\brief Class name. Can be NULL."]
    pub class_file_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Source file name. Can be NULL."]
    pub source_file_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Module name. Can be NULL.\nThe module name can be useful for distinguishing among\ndifferent JIT engines. VTune Profiler will display\nreported methods grouped by specific module."]
    pub module_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__iJIT_Method_Load_V2() {
    const UNINIT: ::std::mem::MaybeUninit<_iJIT_Method_Load_V2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iJIT_Method_Load_V2>(),
        64usize,
        concat!("Size of: ", stringify!(_iJIT_Method_Load_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_iJIT_Method_Load_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(_iJIT_Method_Load_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(method_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(method_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_load_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(method_load_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(method_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(line_number_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_table) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(line_number_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_file_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(class_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_file_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(source_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V2),
            "::",
            stringify!(module_name)
        )
    );
}
#[doc = " @brief Description of a JIT-compiled method\n @details When you use the iJIT_Method_Load_V2 structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2\n  as an event type to report it."]
pub type piJIT_Method_Load_V2 = *mut _iJIT_Method_Load_V2;
#[doc = " @brief Description of a JIT-compiled method\n @details When you use the iJIT_Method_Load_V2 structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V2\n  as an event type to report it."]
pub type iJIT_Method_Load_V2 = _iJIT_Method_Load_V2;
#[doc = " @brief Description of a JIT-compiled method\n @details The iJIT_Method_Load_V3 structure is the same as iJIT_Method_Load_V2\n  with a newly introduced 'arch' field that specifies architecture of the code region.\n  When you use the iJIT_Method_Load_V3 structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V3\n  as an event type to report it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iJIT_Method_Load_V3 {
    #[doc = "<\\brief Unique method ID. Cannot be 0.\n  You must either use the API function\n  iJIT_GetNewMethodID to get a valid and unique\n  method ID, or manage ID uniqueness\n  and correct range by yourself.\\n\n  You must use the same method ID for all code\n  regions of the same method, otherwise they are\n  treated as regions of different methods."]
    pub method_id: ::std::os::raw::c_uint,
    #[doc = "<\\brief The name of the method. It can be optionally\n  prefixed with its class name and appended with\n  its complete signature. Cannot be  NULL."]
    pub method_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief The start virtual address of the method code\n  region. If NULL, then data provided with the\n  event are not accepted."]
    pub method_load_address: *mut ::std::os::raw::c_void,
    #[doc = "<\\brief The code size of the method in memory.\n  If 0, then data provided with the event are not\n  accepted."]
    pub method_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief The number of entries in the line number\n  table. 0 if none."]
    pub line_number_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief Pointer to the line numbers info\n  array. Can be NULL if\n  line_number_size is 0. See\n  LineNumberInfo Structure for a\n  description of a single entry in\n  the line number info array."]
    pub line_number_table: pLineNumberInfo,
    #[doc = "<\\brief Class name. Can be NULL."]
    pub class_file_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Source file name. Can be NULL."]
    pub source_file_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Module name. Can be NULL.\n  The module name can be useful for distinguishing among\n  different JIT engines. VTune Profiler will display\n  reported methods grouped by specific module."]
    pub module_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Architecture of the method's code region.\n  By default, it is the same as the process\n  architecture that is calling it.\n  For example, you can use it if your 32-bit JIT\n  engine generates 64-bit code.\n\n  If JIT engine reports both 32-bit and 64-bit types\n  of methods then VTune Profiler splits the methods\n  with the same module name but with different\n  architectures in two different modules. VTune Profiler\n  modifies the original name provided with a 64-bit method\n  version by ending it with '(64)'"]
    pub module_arch: iJIT_CodeArchitecture,
}
#[test]
fn bindgen_test_layout__iJIT_Method_Load_V3() {
    const UNINIT: ::std::mem::MaybeUninit<_iJIT_Method_Load_V3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iJIT_Method_Load_V3>(),
        72usize,
        concat!("Size of: ", stringify!(_iJIT_Method_Load_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_iJIT_Method_Load_V3>(),
        8usize,
        concat!("Alignment of ", stringify!(_iJIT_Method_Load_V3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(method_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(method_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_load_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(method_load_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(method_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(line_number_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_table) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(line_number_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_file_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(class_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_file_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(source_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(module_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_arch) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Load_V3),
            "::",
            stringify!(module_arch)
        )
    );
}
#[doc = " @brief Description of a JIT-compiled method\n @details The iJIT_Method_Load_V3 structure is the same as iJIT_Method_Load_V2\n  with a newly introduced 'arch' field that specifies architecture of the code region.\n  When you use the iJIT_Method_Load_V3 structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V3\n  as an event type to report it."]
pub type piJIT_Method_Load_V3 = *mut _iJIT_Method_Load_V3;
#[doc = " @brief Description of a JIT-compiled method\n @details The iJIT_Method_Load_V3 structure is the same as iJIT_Method_Load_V2\n  with a newly introduced 'arch' field that specifies architecture of the code region.\n  When you use the iJIT_Method_Load_V3 structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_LOAD_FINISHED_V3\n  as an event type to report it."]
pub type iJIT_Method_Load_V3 = _iJIT_Method_Load_V3;
#[doc = " @brief Description of an inline JIT-compiled method\n @details When you use the_iJIT_Method_Inline_Load structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED\n  as an event type to report it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iJIT_Method_Inline_Load {
    #[doc = "<\\brief Unique method ID. Cannot be 0.\n  You must either use the API function\n  iJIT_GetNewMethodID to get a valid and unique\n  method ID, or else manage ID uniqueness\n  and correct range by yourself."]
    pub method_id: ::std::os::raw::c_uint,
    #[doc = "<\\brief Unique immediate parent's method ID.\n  Cannot be 0.\n  You must either use the API function\n  iJIT_GetNewMethodID to get a valid and unique\n  method ID, or else manage ID uniqueness\n  and correct range by yourself."]
    pub parent_method_id: ::std::os::raw::c_uint,
    #[doc = "<\\brief The name of the method. It can be optionally\n  prefixed with its class name and appended with\n  its complete signature. Can't be NULL."]
    pub method_name: *mut ::std::os::raw::c_char,
    pub method_load_address: *mut ::std::os::raw::c_void,
    #[doc = "<\\brief The code size of the method in memory.\n  If 0, then data provided with the event are not\n  accepted."]
    pub method_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief The number of entries in the line number\n  table. 0 if none."]
    pub line_number_size: ::std::os::raw::c_uint,
    #[doc = "<\\brief Pointer to the line numbers info\n  array. Can be NULL if\n  line_number_size is 0. See\n  LineNumberInfo Structure for a\n  description of a single entry in\n  the line number info array"]
    pub line_number_table: pLineNumberInfo,
    #[doc = "<\\brief Class name. Can be NULL."]
    pub class_file_name: *mut ::std::os::raw::c_char,
    #[doc = "<\\brief Source file name. Can be NULL."]
    pub source_file_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__iJIT_Method_Inline_Load() {
    const UNINIT: ::std::mem::MaybeUninit<_iJIT_Method_Inline_Load> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iJIT_Method_Inline_Load>(),
        56usize,
        concat!("Size of: ", stringify!(_iJIT_Method_Inline_Load))
    );
    assert_eq!(
        ::std::mem::align_of::<_iJIT_Method_Inline_Load>(),
        8usize,
        concat!("Alignment of ", stringify!(_iJIT_Method_Inline_Load))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(method_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_method_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(parent_method_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(method_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_load_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(method_load_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(method_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(line_number_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_number_table) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(line_number_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_file_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(class_file_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_file_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Inline_Load),
            "::",
            stringify!(source_file_name)
        )
    );
}
#[doc = " @brief Description of an inline JIT-compiled method\n @details When you use the_iJIT_Method_Inline_Load structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED\n  as an event type to report it."]
pub type piJIT_Method_Inline_Load = *mut _iJIT_Method_Inline_Load;
#[doc = " @brief Description of an inline JIT-compiled method\n @details When you use the_iJIT_Method_Inline_Load structure to describe\n  the JIT compiled method, use iJVM_EVENT_TYPE_METHOD_INLINE_LOAD_FINISHED\n  as an event type to report it."]
pub type iJIT_Method_Inline_Load = _iJIT_Method_Inline_Load;
pub const _iJIT_SegmentType_iJIT_CT_UNKNOWN: _iJIT_SegmentType = 0;
#[doc = "<\\brief Executable code."]
pub const _iJIT_SegmentType_iJIT_CT_CODE: _iJIT_SegmentType = 1;
#[doc = "<\\brief Data (not executable code).\n VTune Profiler uses the format string\n (see iJIT_Method_Update) to represent\n this data in the VTune Profiler GUI"]
pub const _iJIT_SegmentType_iJIT_CT_DATA: _iJIT_SegmentType = 2;
#[doc = "<\\brief Use the previous markup for the trace.\n Can be used for the following\n iJVM_EVENT_TYPE_METHOD_UPDATE_V2 events,\n if the type of the previously reported segment\n type is the same."]
pub const _iJIT_SegmentType_iJIT_CT_KEEP: _iJIT_SegmentType = 3;
pub const _iJIT_SegmentType_iJIT_CT_EOF: _iJIT_SegmentType = 4;
#[doc = " @cond exclude_from_documentation */\n/**\n @brief Description of a segment type\n @details Use the segment type to specify a type of data supplied\n with the iJVM_EVENT_TYPE_METHOD_UPDATE_V2 event to be applied to\n a certain code trace."]
pub type _iJIT_SegmentType = ::std::os::raw::c_uint;
#[doc = " @cond exclude_from_documentation */\n/**\n @brief Description of a segment type\n @details Use the segment type to specify a type of data supplied\n with the iJVM_EVENT_TYPE_METHOD_UPDATE_V2 event to be applied to\n a certain code trace."]
pub use self::_iJIT_SegmentType as iJIT_SegmentType;
#[doc = " @brief Description of a dynamic update of the content within JIT-compiled method\n @details The JIT engine may generate the methods that are updated at runtime\n partially by mixed (data + executable code) content. When you use the iJIT_Method_Update\n structure to describe the update of the content within a JIT-compiled method,\n use iJVM_EVENT_TYPE_METHOD_UPDATE_V2 as an event type to report it.\n\n On the first Update event, VTune Profiler copies the original code range reported by\n the iJVM_EVENT_TYPE_METHOD_LOAD event, then modifies it with the supplied bytes and\n adds the modified range to the original method. For next update events, VTune Profiler\n does the same but it uses the latest modified version of a code region for update.\n Eventually, VTune Profiler GUI displays multiple code ranges for the method reported by\n the iJVM_EVENT_TYPE_METHOD_LOAD event.\n Notes:\n - Multiple update events with different types for the same trace are allowed\n   but they must be reported for the same code ranges.\n   Example,\n @code\n                      [-- data---]        Allowed\n          [-- code --]                    Allowed\n        [code]                            Ignored\n                      [-- data---]        Allowed\n          [-- code --]                    Allowed\n      [------------ trace ---------]\n @endcode\n - The types of previously reported events can be changed but they must be reported\n   for the same code ranges.\n   Example,\n @code\n          [-- data---]                    Allowed\n          [-- code --]                    Allowed\n          [-- data---]                    Allowed\n          [-- code --]                    Allowed\n      [------------ trace ---------]\n @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iJIT_Method_Update {
    #[doc = "<\\brief Start address of the update within a method"]
    pub load_address: *mut ::std::os::raw::c_void,
    #[doc = "<\\brief The update size"]
    pub size: ::std::os::raw::c_uint,
    #[doc = "<\\brief Type of the update"]
    pub type_: iJIT_SegmentType,
    #[doc = "<\\brief C string that contains a format string\n that follows the same specifications as format in printf.\n The format string is used for iJIT_CT_CODE only\n and cannot be NULL.\n Format can be changed on the fly."]
    pub data_format: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__iJIT_Method_Update() {
    const UNINIT: ::std::mem::MaybeUninit<_iJIT_Method_Update> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iJIT_Method_Update>(),
        24usize,
        concat!("Size of: ", stringify!(_iJIT_Method_Update))
    );
    assert_eq!(
        ::std::mem::align_of::<_iJIT_Method_Update>(),
        8usize,
        concat!("Alignment of ", stringify!(_iJIT_Method_Update))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Update),
            "::",
            stringify!(load_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Update),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Update),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_iJIT_Method_Update),
            "::",
            stringify!(data_format)
        )
    );
}
#[doc = " @brief Description of a dynamic update of the content within JIT-compiled method\n @details The JIT engine may generate the methods that are updated at runtime\n partially by mixed (data + executable code) content. When you use the iJIT_Method_Update\n structure to describe the update of the content within a JIT-compiled method,\n use iJVM_EVENT_TYPE_METHOD_UPDATE_V2 as an event type to report it.\n\n On the first Update event, VTune Profiler copies the original code range reported by\n the iJVM_EVENT_TYPE_METHOD_LOAD event, then modifies it with the supplied bytes and\n adds the modified range to the original method. For next update events, VTune Profiler\n does the same but it uses the latest modified version of a code region for update.\n Eventually, VTune Profiler GUI displays multiple code ranges for the method reported by\n the iJVM_EVENT_TYPE_METHOD_LOAD event.\n Notes:\n - Multiple update events with different types for the same trace are allowed\n   but they must be reported for the same code ranges.\n   Example,\n @code\n                      [-- data---]        Allowed\n          [-- code --]                    Allowed\n        [code]                            Ignored\n                      [-- data---]        Allowed\n          [-- code --]                    Allowed\n      [------------ trace ---------]\n @endcode\n - The types of previously reported events can be changed but they must be reported\n   for the same code ranges.\n   Example,\n @code\n          [-- data---]                    Allowed\n          [-- code --]                    Allowed\n          [-- data---]                    Allowed\n          [-- code --]                    Allowed\n      [------------ trace ---------]\n @endcode"]
pub type piJIT_Method_Update = *mut _iJIT_Method_Update;
#[doc = " @brief Description of a dynamic update of the content within JIT-compiled method\n @details The JIT engine may generate the methods that are updated at runtime\n partially by mixed (data + executable code) content. When you use the iJIT_Method_Update\n structure to describe the update of the content within a JIT-compiled method,\n use iJVM_EVENT_TYPE_METHOD_UPDATE_V2 as an event type to report it.\n\n On the first Update event, VTune Profiler copies the original code range reported by\n the iJVM_EVENT_TYPE_METHOD_LOAD event, then modifies it with the supplied bytes and\n adds the modified range to the original method. For next update events, VTune Profiler\n does the same but it uses the latest modified version of a code region for update.\n Eventually, VTune Profiler GUI displays multiple code ranges for the method reported by\n the iJVM_EVENT_TYPE_METHOD_LOAD event.\n Notes:\n - Multiple update events with different types for the same trace are allowed\n   but they must be reported for the same code ranges.\n   Example,\n @code\n                      [-- data---]        Allowed\n          [-- code --]                    Allowed\n        [code]                            Ignored\n                      [-- data---]        Allowed\n          [-- code --]                    Allowed\n      [------------ trace ---------]\n @endcode\n - The types of previously reported events can be changed but they must be reported\n   for the same code ranges.\n   Example,\n @code\n          [-- data---]                    Allowed\n          [-- code --]                    Allowed\n          [-- data---]                    Allowed\n          [-- code --]                    Allowed\n      [------------ trace ---------]\n @endcode"]
pub type iJIT_Method_Update = _iJIT_Method_Update;
extern "C" {
    #[doc = " @brief Generates a new unique method ID.\n\n You must use this API to obtain unique and valid method IDs for methods or\n traces reported to the agent if you don't have your own mechanism to generate\n unique method IDs.\n\n @return a new unique method ID. When out of unique method IDs, this API\n returns 0, which is not an accepted value."]
    pub fn iJIT_GetNewMethodID() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief Returns the current mode of the agent.\n\n @return iJIT_SAMPLING_ON, indicating that agent is running, or\n iJIT_NOTHING_RUNNING if no agent is running."]
    pub fn iJIT_IsProfilingActive() -> iJIT_IsProfilingActiveFlags;
}
extern "C" {
    #[doc = " @brief Reports infomation about JIT-compiled code to the agent.\n\n The reported information is used to attribute samples obtained from any\n Intel(R) VTune(TM) Profiler collector. This API needs to be called\n after JIT compilation and before the first entry into the JIT-compiled\n code.\n\n @param[in] event_type - type of the data sent to the agent\n @param[in] EventSpecificData - pointer to event-specific data\n\n @returns 1 on success, otherwise 0."]
    pub fn iJIT_NotifyEvent(
        event_type: iJIT_JVM_EVENT,
        EventSpecificData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
